package com.example.matrix_events.database;


import android.util.Log;
import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;

import java.util.ArrayList;

/**
 * A generic connector class for interacting with a Google Firestore collection.
 * This class provides asynchronous methods for creating, reading, updating,
 * and deleting documents. It is designed to work with any class that extends
 * {@link DBObject}.
 *
 * @param <T> The type of object this connector will handle, which must extend {@link DBObject}.
 */
public class DBConnector<T extends DBObject> {
    private static final String TAG = "DBConnector";

    // Firestore collection reference
    private final CollectionReference collectionRef;

    /**
     * Constructs a DBConnector and sets up a real-time listener on a specified Firestore collection.
     * The listener will asynchronously provide updates to the caller via the {@link DBListener} interface.
     *
     * @param collection The name of the Firestore collection to connect to.
     * @param listener   The listener that will receive callbacks with the data from the collection.
     * @param objectType The class of the object type T, used for mapping Firestore documents to Java objects.
     */
    public DBConnector(String collection, DBListener<T> listener, Class<T> objectType) {
        FirebaseFirestore db = FirebaseFirestore.getInstance();
        collectionRef = db.collection(collection);
        collectionRef
                .addSnapshotListener((snapshots, e) -> {
                    if (e != null) {
                        Log.w(TAG, "FireStore collection listener failed", e);
                        return;
                    }
                    if (snapshots == null) {
                        Log.w(TAG, "FireStore collection no snapshot data received");
                        return;
                    }
                    Log.d(TAG, "FireStore collection registered an update. Reading collection of " + snapshots.size() + " documents");

                    ArrayList<T> objectList = new ArrayList<>();
                    for (DocumentSnapshot documentSnapshot : snapshots.getDocuments()) {
                        T object = documentSnapshot.toObject(objectType);
                        if (object != null) {
                            object.setId(documentSnapshot.getId());
                            objectList.add(object);
                        }
                    }
                    listener.readAllAsync_Complete(objectList);
                });
    }

    /**
     * Asynchronously creates a new document in the Firestore collection.
     * Upon successful creation, the object's ID is updated with the ID generated by Firestore.
     *
     * @param object The object to be added to the Firestore collection.
     */
    public void createAsync(T object) {
        Log.d(TAG, "Attempting to create document");
        collectionRef
                .add(object)
                .addOnSuccessListener(documentReference -> {
                    Log.d(TAG, "Document created with ID: " + documentReference.getId());
                    object.setId(documentReference.getId());
                    collectionRef.document(object.getId()).update("id", object.getId());
                })
                .addOnFailureListener(e -> Log.w(TAG, "Error creating document", e));
    }

    /**
     * Asynchronously updates an existing document in the Firestore collection.
     * The object's ID is used to identify the document to be updated.
     *
     * @param object The object containing the updated data. Must have a non-null and non-empty ID.
     */
    public void updateAsync(T object) {
        Log.d(TAG, "Attempting to update document");
        if (object == null || object.getId().isEmpty()) {
            Log.w(TAG, "Cannot update object with null or empty ID");
            return;
        }
        collectionRef
                .document(object.getId())
                .set(object)
                .addOnSuccessListener(command -> {
                    Log.d(TAG, "Document with ID: " + object.getId() + " successfully updated");
                })
                .addOnFailureListener(e -> Log.w(TAG, "Error updating document", e));
    }

    /**
     * Asynchronously deletes a document from the Firestore collection.
     * The object's ID is used to identify the document to be deleted.
     *
     * @param object The object to be deleted. Must have a non-null and non-empty ID.
     */
    public void deleteAsync(T object) {
        Log.d(TAG, "Attempting to delete document");
        if (object == null || object.getId().isEmpty()) {
            Log.w(TAG, "Cannot delete object with null or empty ID");
            return;
        }
        collectionRef
                .document(object.getId())
                .delete()
                .addOnSuccessListener(command -> {
                    Log.d(TAG, "Document with ID: " + object.getId() + " successfully deleted");
                })
                .addOnFailureListener(e -> Log.w(TAG, "Error deleting document", e));
    }
}
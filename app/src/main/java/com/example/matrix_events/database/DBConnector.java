package com.example.matrix_events.database;

import android.util.Log;
import androidx.annotation.NonNull;

import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;

import java.util.ArrayList;

/**
 * A generic connector class for interacting with a Google Firestore collection.
 * <p>
 * This class provides asynchronous methods for creating, reading, updating,
 * and deleting documents. It is designed to work with any class that extends
 * {@link DBObject}.
 * </p>
 * <p>
 * Uniquely, this connector establishes a real-time {@link com.google.firebase.firestore.EventListener}
 * upon instantiation. This means the associated {@link DBListener} will be triggered
 * not only on the initial data fetch but also whenever the database contents change
 * on the server side.
 * </p>
 *
 * @param <T> The type of object this connector will handle, which must extend {@link DBObject}.
 */
public class DBConnector<T extends DBObject> {
    private static final String TAG = "DBConnector";

    // Firestore collection reference
    private final CollectionReference collectionRef;

    /**
     * Constructs a DBConnector and sets up a real-time listener on a specified Firestore collection.
     * <p>
     * The listener will asynchronously provide updates to the caller via the {@link DBListener} interface.
     * When data is received, it deserializes the Firestore documents into objects of type {@code T}
     * and automatically populates their internal ID fields.
     * </p>
     *
     * @param collection The name of the Firestore collection to connect to (e.g., "events", "users").
     * @param listener   The listener that will receive callbacks with the data from the collection.
     * @param objectType The class of the object type T. This is required for Firestore's
     * automatic JSON-to-Object mapping.
     */
    public DBConnector(@NonNull String collection, @NonNull DBListener<T> listener, @NonNull Class<T> objectType) {
        FirebaseFirestore db = FirebaseFirestore.getInstance();
        collectionRef = db.collection(collection);
        collectionRef
                .addSnapshotListener((snapshots, e) -> {
                    if (e != null) {
                        Log.w(TAG, "FireStore collection listener failed", e);
                        return;
                    }
                    if (snapshots == null) {
                        Log.w(TAG, "FireStore collection no snapshot data received");
                        return;
                    }
                    Log.d(TAG, "FireStore collection registered an update. Reading collection of " + snapshots.size() + " documents");

                    ArrayList<T> objectList = new ArrayList<>();
                    for (DocumentSnapshot documentSnapshot : snapshots.getDocuments()) {
                        T object = documentSnapshot.toObject(objectType);
                        if (object != null) {
                            object.setId(documentSnapshot.getId());
                            objectList.add(object);
                        }
                    }
                    listener.readAllAsync_Complete(objectList);
                });
    }

    /**
     * Asynchronously creates a new document in the Firestore collection.
     * <p>
     * Upon successful creation, the method retrieves the unique ID generated by Firestore,
     * sets it in the local {@code object}, and performs a subsequent update to the
     * Firestore document to ensure the "id" field in the database matches the document key.
     * </p>
     *
     * @param object The object to be added to the Firestore collection. Cannot be null.
     */
    public void createAsync(@NonNull T object) {
        Log.d(TAG, "Attempting to create document");
        collectionRef
                .add(object)
                .addOnSuccessListener(documentReference -> {
                    Log.d(TAG, "Document created with ID: " + documentReference.getId());
                    object.setId(documentReference.getId());
                    // Sync the generated ID back into the document fields
                    collectionRef.document(object.getId()).update("id", object.getId());
                })
                .addOnFailureListener(e -> Log.w(TAG, "Error creating document", e));
    }

    /**
     * Asynchronously updates an existing document in the Firestore collection.
     * <p>
     * The object's ID is used to identify the document to be updated. This method uses
     * {@link com.google.firebase.firestore.DocumentReference#set(Object)} which overwrites
     * the document data with the new object data.
     * </p>
     *
     * @param object The object containing the updated data. Must have a non-null and non-empty ID.
     */
    public void updateAsync(@NonNull T object) {
        Log.d(TAG, "Attempting to update document");
        if (object == null || object.getId() == null || object.getId().isEmpty()) {
            Log.w(TAG, "Cannot update object with null or empty ID");
            return;
        }
        collectionRef
                .document(object.getId())
                .set(object)
                .addOnSuccessListener(command -> {
                    Log.d(TAG, "Document with ID: " + object.getId() + " successfully updated");
                })
                .addOnFailureListener(e -> Log.w(TAG, "Error updating document", e));
    }

    /**
     * Asynchronously deletes a document from the Firestore collection.
     * <p>
     * The object's ID is used to identify the document to be deleted.
     * </p>
     *
     * @param object The object to be deleted. Must have a non-null and non-empty ID.
     */
    public void deleteAsync(@NonNull T object) {
        Log.d(TAG, "Attempting to delete document");
        if (object == null || object.getId() == null || object.getId().isEmpty()) {
            Log.w(TAG, "Cannot delete object with null or empty ID");
            return;
        }
        collectionRef
                .document(object.getId())
                .delete()
                .addOnSuccessListener(command -> {
                    Log.d(TAG, "Document with ID: " + object.getId() + " successfully deleted");
                })
                .addOnFailureListener(e -> Log.w(TAG, "Error deleting document", e));
    }
}
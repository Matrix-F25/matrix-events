package com.example.matrix_events.managers;

import android.net.Uri;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.example.matrix_events.database.DBConnector;
import com.example.matrix_events.database.DBListener;
import com.example.matrix_events.entities.Profile;
import com.example.matrix_events.mvc.Model;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.storage.FirebaseStorage;
import com.google.firebase.storage.StorageReference;
import com.google.firebase.storage.UploadTask;

import java.util.ArrayList;
import java.util.List;

/**
 * Manages all user profile data and operations within the application.
 * <p>
 * This class follows the singleton pattern to provide a single point of access to profile data.
 * It acts as the <b>Model</b> in the MVC architecture, connecting to:
 * <ul>
 * <li><b>Firestore:</b> To sync profile data (names, preferences, FCM tokens).</li>
 * <li><b>Firebase Storage:</b> To handle profile picture uploads.</li>
 * </ul>
 * It notifies all registered {@link com.example.matrix_events.mvc.View}s whenever data changes.
 * </p>
 */
public class ProfileManager extends Model implements DBListener<Profile> {
    private static final String TAG = "ProfileManager";
    private List<Profile> profiles = new ArrayList<>();
    private final DBConnector<Profile> connector = new DBConnector<>("profiles", this, Profile.class);
    private final FirebaseStorage storage = FirebaseStorage.getInstance();
    private final StorageReference profileStorageRef = storage.getReference("profiles"); // Profile Folder in Firebase Storage

    // Singleton Instance
    private static final ProfileManager manager = new ProfileManager();

    /**
     * Gets the singleton instance of the ProfileManager.
     *
     * @return The single, static instance of ProfileManager.
     */
    public static ProfileManager getInstance() { return manager; }

    /**
     * Interface for handling profile image upload results.
     */
    public interface ProfileImageUploadCallback {
        void onSuccess(String downloadUrl);
        void onFailure(Exception e);
    }

    // --- Profile Getters ---

    /**
     * Retrieves the local cache of all user profiles.
     *
     * @return A list of all {@link Profile} objects currently held by the manager.
     */
    @NonNull
    public List<Profile> getProfiles() {
        return profiles;
    }

    /**
     * Finds and retrieves a profile by its unique Firestore document ID.
     * <p>
     * Note: This searches for the internal ID generated by Firestore, not the device ID.
     * </p>
     *
     * @param id The Firestore document ID of the profile. Cannot be null.
     * @return The {@link Profile} object with the matching ID, or {@code null} if no profile is found.
     */
    @Nullable
    public Profile getProfileByDBID(@NonNull String id) {
        for (Profile profile : profiles) {
            if (profile.getId() != null && profile.getId().equals(id)) {
                return profile;
            }
        }
        return null;
    }

    /**
     * Finds and retrieves a profile by the user's unique device ID.
     * <p>
     * This is the primary method used to identify the "Current User" of the app.
     * </p>
     *
     * @param deviceId The device ID associated with the profile.
     * @return The {@link Profile} object with the matching device ID, or {@code null} if not found.
     */
    @Nullable
    public Profile getProfileByDeviceId(@NonNull String deviceId) {
        for (Profile profile : profiles) {
            // Check for null to prevent crashes on malformed data
            if (profile.getDeviceId() != null && profile.getDeviceId().equals(deviceId)) {
                return profile;
            }
        }
        return null;
    }

    /**
     * Checks if a profile associated with a given device ID exists.
     *
     * @param deviceId The device ID to check for. Cannot be null.
     * @return {@code true} if a profile with the specified device ID exists, {@code false} otherwise.
     */
    public boolean doesProfileExist(@NonNull String deviceId) {
        return getProfileByDeviceId(deviceId) != null;
    }

    // --- CRUD Operations ---

    /**
     * Asynchronously creates a new profile in the Firestore database.
     *
     * @param profile The {@link Profile} object to create. Cannot be null.
     */
    public void createProfile(@NonNull Profile profile) {
        connector.createAsync(profile);
    }

    /**
     * Asynchronously updates an existing profile in the Firestore database.
     *
     * @param profile The {@link Profile} object with updated data. Its ID must be set. Cannot be null.
     */
    public void updateProfile(@NonNull Profile profile) {
        connector.updateAsync(profile);
    }

    /**
     * Asynchronously deletes a profile from the Firestore database.
     * <p>
     * <b>Note:</b> When a profile is deleted, care should be taken to remove the user
     * from any events they have joined. This logic is handled by {@link EventManager#removeFromAllEvents(String)}.
     * </p>
     *
     * @param profile The {@link Profile} object to delete. Its ID must be set. Cannot be null.
     */
    public void deleteProfile(@NonNull Profile profile) {
        connector.deleteAsync(profile);
    }

    // --- Specialized Operations ---

    /**
     * Updates the Firebase Cloud Messaging (FCM) token for a specific user.
     * <p>
     * This method queries the database directly to find the profile associated with the device ID
     * and updates its 'FCMToken' field. This allows the user to receive push notifications
     * even if the app hasn't fully loaded the local cache yet.
     * </p>
     *
     * @param deviceId The unique Device ID of the user.
     * @param token    The new FCM token generated by the messaging service.
     */
    public void updateFCMToken(String deviceId, String token) {
        FirebaseFirestore.getInstance()
                .collection("profiles")
                .whereEqualTo("deviceId", deviceId)
                .get()
                .addOnSuccessListener(querySnapshot -> {
                    if (!querySnapshot.isEmpty()) {
                        // Found profile, update token
                        querySnapshot.getDocuments().get(0).getReference().update("FCMToken", token)
                                .addOnSuccessListener(v -> Log.d(TAG, "FCM Token updated successfully via Manager."));
                    }
                })
                .addOnFailureListener(e -> Log.e(TAG, "Failed to update FCM token via Manager", e));
    }

    /**
     * Uploads a profile image to Firebase Storage and updates the profile in Firestore.
     * <p>
     * This method handles:
     * <ol>
     * <li>Deleting the old profile picture (if one exists and is different).</li>
     * <li>Uploading the new image file.</li>
     * <li>Updating the {@link Profile} object with the new URL and Filename.</li>
     * <li>Saving the updated profile to Firestore.</li>
     * </ol>
     * </p>
     *
     * @param imageUri The local URI of the image to upload.
     * @param profile  The user profile to update.
     * @param callback Callback to handle success/failure UI updates.
     */
    public void uploadProfilePicture(Uri imageUri, Profile profile, ProfileImageUploadCallback callback) {
        if (imageUri == null || profile == null) {
            callback.onFailure(new IllegalArgumentException("Missing image or profile"));
            return;
        }
        // Ensure Profile has an ID
        if (profile.getId() == null || profile.getId().isEmpty()) {
            callback.onFailure(new IllegalStateException("Profile ID not set"));
            return;
        }

        // Permanent Filename per User for Replacement (prevents storage clutter)
        String fileName = "profile_" + profile.getDeviceId() + ".jpg";

        // If profile already has a stored file name, delete the old file safely
        String previousFile = profile.getProfilePictureFileName();
        if (previousFile != null && !previousFile.isEmpty() && !previousFile.equals(fileName)) {
            StorageReference oldRef = profileStorageRef.child(previousFile);
            oldRef.delete().addOnSuccessListener(a -> {
                Log.d(TAG, "Old Profile Picture Deleted.");
            }).addOnFailureListener(e -> {
                Log.w(TAG, "Failed to Delete Old Profile Picture.", e);
            });
        }

        StorageReference ref = profileStorageRef.child(fileName);

        UploadTask uploadTask = ref.putFile(imageUri);
        uploadTask.continueWithTask(task -> {
            if (!task.isSuccessful()) throw task.getException();
            return ref.getDownloadUrl();
        }).addOnSuccessListener(uri -> {
            String downloadUrl = uri.toString();

            // Update Local Object
            profile.setProfilePictureUrl(downloadUrl);
            profile.setProfilePictureFileName(fileName);

            // Update Database
            updateProfile(profile);

            callback.onSuccess(downloadUrl);
        }).addOnFailureListener(callback::onFailure);
    }

    /**
     * Callback method invoked by {@link DBConnector} when the profile data changes in Firestore.
     * <p>
     * Updates the local profile cache and notifies all registered views of the change.
     * Handles null-safety to prevent clearing the list if the database returns an error state.
     * </p>
     *
     * @param objects The updated list of {@link Profile} objects from Firestore.
     */
    @Override
    public void readAllAsync_Complete(@NonNull List<Profile> objects) {
        Log.d(TAG, "ProfileManager read all complete, notifying views");
        if (objects != null) {
            profiles.clear();
            profiles.addAll(objects);
            // Notify views of profile changes
            notifyViews();
        } else {
            Log.w(TAG, "Received null list from DBConnector. Skipping update.");
        }
    }
}
